
arch/x86/boot/.debug_setup:     file format elf32-i386
arch/x86/boot/.debug_setup
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000005

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000137 memsz 0x00000137 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000137  00000000  00000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000020  00000000  00000000  00001138  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  2 .debug_info   00000026  00000000  00000000  00001158  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  3 .debug_abbrev 00000014  00000000  00000000  0000117e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_line   0000009d  00000000  00000000  00001192  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_str    0000005f  00000000  00000000  0000122f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 setup.o
00009000 l       *ABS*	00000000 INITSEG
00001000 l       *ABS*	00000000 SYSSEG
00009020 l       *ABS*	00000000 SETUPSEG
00000071 l       .text	00000000 no_disk1
00000081 l       .text	00000000 is_disk1
00000086 l       .text	00000000 do_move
0000009d l       .text	00000000 end_move
0000012b l       .text	00000000 idt_48
00000131 l       .text	00000000 gdt_48
00000008 l       *ABS*	00000000 sel_cs0
00000108 l       .text	00000000 empty_8042
00000113 l       .text	00000000 gdt
00000137 g       .text	00000000 endtext
00000000 g       .text	00000000 begtext
00000005 g       .text	00000000 _start
00001000 g       .text	00000000 __bss_start
00001000 g       .text	00000000 begdata
00001000 g       .text	00000000 endbss
00001000 g       .text	00000000 enddata
00001000 g       .text	00000000 _edata
00001000 g       .text	00000000 _end
00001000 g       .text	00000000 begbss


Contents of section .text:
 0000 ea050020 90b80090 8ed8b403 30ffcd10  ... ........0...
 0010 89160000 b488cd15 a30200b4 0fcd1089  ................
 0020 1e0400a3 0600b412 b310cd10 a3080089  ................
 0030 1e0a0089 0e0c00b8 00008ed8 c5360401  .............6..
 0040 b800908e c0bf8000 b91000f3 a4b80000  ................
 0050 8ed8c536 1801b800 908ec0bf 9000b910  ...6............
 0060 00f3a4b8 0015b281 cd137205 80fc0374  ..........r....t
 0070 10b80090 8ec0bf90 00b91000 b80000f3  ................
 0080 aafab800 00fc8ec0 0500103d 0090740d  ...........=..t.
 0090 8ed829ff 29f6b900 80f3a5eb e9b82090  ..).)......... .
 00a0 8ed80f01 1e2b010f 01163101 e4920c02  .....+....1.....
 00b0 e692b011 e620eb00 eb00e6a0 eb00eb00  ..... ..........
 00c0 b020e621 eb00eb00 b028e6a1 eb00eb00  . .!.....(......
 00d0 b004e621 eb00eb00 b002e6a1 eb00eb00  ...!............
 00e0 b001e621 eb00eb00 e6a1eb00 eb00b0ff  ...!............
 00f0 e621eb00 eb00e6a1 0f20c066 0fbae800  .!....... .f....
 0100 0f22c0ea 00000800 eb00eb00 e464a802  ."...........d..
 0110 75f6c300 00000000 000000ff 07000000  u...............
 0120 9ac000ff 07000000 92c00000 00000000  ................
 0130 00000813 030900                      .......         
Contents of section .debug_aranges:
 0000 1c000000 02000000 00000400 00000000  ................
 0010 00000000 37010000 00000000 00000000  ....7...........
Contents of section .debug_info:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00000000 37010000 00000000 08000000  ....7...........
 0020 53000000 0180                        S.....          
Contents of section .debug_abbrev:
 0000 01110010 06110112 01030e1b 0e250e13  .............%..
 0010 05000000                             ....            
Contents of section .debug_line:
 0000 99000000 03001e00 00000101 fb0e0d00  ................
 0010 01010101 00000001 00000100 73657475  ............setu
 0020 702e7300 00000000 00050200 00000003  p.s.............
 0030 28015e3d 2f2f2f2f 4d2f2f40 2f2f4b40  (.^=////M//@//K@
 0040 2f2f2f3d 4b4e3d2f 4b3d2f3d 3d21243d  ///=KN=/K=/==!$=
 0050 2f4b3d2f 3d3d2124 3d2f2f2f 3d303d2f  /K=/==!$=///=0=/
 0060 3d3d3d21 25243d22 2f3d3d2f 2f2f2f3d  ===!%$="/==////=
 0070 2121333d 2f59030b 582f2f03 0a2e3068  !!3=/Y..X//...0h
 0080 682f682f 682f682f 682f6868 2f68030d  h/h/h/h/h/hh/h..
 0090 2e3d5940 972f2f2f 02250001 01        .=Y@.///.%...   
Contents of section .debug_str:
 0000 73657475 702e7300 2f686f6d 652f7562  setup.s./home/ub
 0010 756e7475 2f426973 63756974 4f532f6f  untu/BiscuitOS/o
 0020 75747075 742f6c69 6e75782d 302e3131  utput/linux-0.11
 0030 2f6c696e 75782f6b 65726e65 6c5f6769  /linux/kernel_gi
 0040 74687562 2f617263 682f7838 362f626f  thub/arch/x86/bo
 0050 6f740047 4e552041 5320322e 333800    ot.GNU AS 2.38. 

Disassembly of section .text:

00000000 <begtext>:
	begdata:
	.bss
	begbss:
	.text

	ljmp $SETUPSEG, $_start	
   0:	ea                   	.byte 0xea
   1:	05                   	.byte 0x5
   2:	00 20                	add    %ah,(%eax)
   4:	90                   	nop

00000005 <_start>:
_start:

# ok, the read went well so we get current cursor position and save it for
# posterity.

	mov	$INITSEG, %ax	# this is done in bootsect already, but...
   5:	b8 00 90 8e d8       	mov    $0xd88e9000,%eax
	mov	%ax, %ds
	mov	$0x03, %ah	# read cursor pos
   a:	b4 03                	mov    $0x3,%ah
	xor	%bh, %bh
   c:	30 ff                	xor    %bh,%bh
	int	$0x10		# save it in known place, con_init fetches
   e:	cd 10                	int    $0x10
	mov	%dx, %ds:0	# it from 0x90000.
  10:	89 16                	mov    %edx,(%esi)
  12:	00 00                	add    %al,(%eax)
# Get memory size (extended mem, kB)

	mov	$0x88, %ah 
  14:	b4 88                	mov    $0x88,%ah
	int	$0x15
  16:	cd 15                	int    $0x15
	mov	%ax, %ds:2
  18:	a3 02 00 b4 0f       	mov    %eax,0xfb40002

# Get video-card data:

	mov	$0x0f, %ah
	int	$0x10
  1d:	cd 10                	int    $0x10
	mov	%bx, %ds:4	# bh = display page
  1f:	89 1e                	mov    %ebx,(%esi)
  21:	04 00                	add    $0x0,%al
	mov	%ax, %ds:6	# al = video mode, ah = window width
  23:	a3 06 00 b4 12       	mov    %eax,0x12b40006

# check for EGA/VGA and some config parameters

	mov	$0x12, %ah
	mov	$0x10, %bl
  28:	b3 10                	mov    $0x10,%bl
	int	$0x10
  2a:	cd 10                	int    $0x10
	mov	%ax, %ds:8
  2c:	a3 08 00 89 1e       	mov    %eax,0x1e890008
	mov	%bx, %ds:10
  31:	0a 00                	or     (%eax),%al
	mov	%cx, %ds:12
  33:	89 0e                	mov    %ecx,(%esi)
  35:	0c 00                	or     $0x0,%al

# Get hd0 data

	mov	$0x0000, %ax
  37:	b8 00 00 8e d8       	mov    $0xd88e0000,%eax
	mov	%ax, %ds
	lds	%ds:4*0x41, %si
  3c:	c5 36                	lds    (%esi),%esi
  3e:	04 01                	add    $0x1,%al
	mov	$INITSEG, %ax
  40:	b8 00 90 8e c0       	mov    $0xc08e9000,%eax
	mov	%ax, %es
	mov	$0x0080, %di
  45:	bf 80 00 b9 10       	mov    $0x10b90080,%edi
	mov	$0x10, %cx
  4a:	00 f3                	add    %dh,%bl
	rep
	movsb
  4c:	a4                   	movsb  %ds:(%esi),%es:(%edi)

# Get hd1 data

	mov	$0x0000, %ax
  4d:	b8 00 00 8e d8       	mov    $0xd88e0000,%eax
	mov	%ax, %ds
	lds	%ds:4*0x46, %si
  52:	c5 36                	lds    (%esi),%esi
  54:	18 01                	sbb    %al,(%ecx)
	mov	$INITSEG, %ax
  56:	b8 00 90 8e c0       	mov    $0xc08e9000,%eax
	mov	%ax, %es
	mov	$0x0090, %di
  5b:	bf 90 00 b9 10       	mov    $0x10b90090,%edi
	mov	$0x10, %cx
  60:	00 f3                	add    %dh,%bl
	rep
	movsb
  62:	a4                   	movsb  %ds:(%esi),%es:(%edi)

# Check that there IS a hd1 :-)

	mov	$0x01500, %ax
  63:	b8 00 15 b2 81       	mov    $0x81b21500,%eax
	mov	$0x81, %dl
	int	$0x13
  68:	cd 13                	int    $0x13
	jc	no_disk1
  6a:	72 05                	jb     71 <no_disk1>
	cmp	$3, %ah
  6c:	80 fc 03             	cmp    $0x3,%ah
	je	is_disk1
  6f:	74 10                	je     81 <is_disk1>

00000071 <no_disk1>:
no_disk1:
	mov	$INITSEG, %ax
  71:	b8 00 90 8e c0       	mov    $0xc08e9000,%eax
	mov	%ax, %es
	mov	$0x0090, %di
  76:	bf 90 00 b9 10       	mov    $0x10b90090,%edi
	mov	$0x10, %cx
  7b:	00 b8 00 00 f3 aa    	add    %bh,-0x550d0000(%eax)

00000081 <is_disk1>:
	stosb
is_disk1:

# now we want to move to protected mode ...

	cli			# no interrupts allowed ! 
  81:	fa                   	cli    

# first we move the system to it's rightful place

	mov	$0x0000, %ax
  82:	b8                   	.byte 0xb8
  83:	00 00                	add    %al,(%eax)
	cld			# 'direction'=0, movs moves forward
  85:	fc                   	cld    

00000086 <do_move>:
do_move:
	mov	%ax, %es	# destination segment
  86:	8e c0                	mov    %eax,%es
	add	$0x1000, %ax
  88:	05 00 10 3d 00       	add    $0x3d1000,%eax
	cmp	$0x9000, %ax
  8d:	90                   	nop
	jz	end_move
  8e:	74 0d                	je     9d <end_move>
	mov	%ax, %ds	# source segment
  90:	8e d8                	mov    %eax,%ds
	sub	%di, %di
  92:	29 ff                	sub    %edi,%edi
	sub	%si, %si
  94:	29 f6                	sub    %esi,%esi
	mov 	$0x8000, %cx
  96:	b9 00 80 f3 a5       	mov    $0xa5f38000,%ecx
	rep
	movsw
	jmp	do_move
  9b:	eb e9                	jmp    86 <do_move>

0000009d <end_move>:

# then we load the segment descriptors

end_move:
	mov	$SETUPSEG, %ax	# right, forgot this at first. didn't work :-)
  9d:	b8 20 90 8e d8       	mov    $0xd88e9020,%eax
	mov	%ax, %ds
	lidt	idt_48		# load idt with 0,0
  a2:	0f 01 1e             	lidtl  (%esi)
  a5:	2b 01                	sub    (%ecx),%eax
	lgdt	gdt_48		# load gdt with whatever appropriate
  a7:	0f 01 16             	lgdtl  (%esi)
  aa:	31 01                	xor    %eax,(%ecx)
	#out	%al, $0x64
	#call	empty_8042
	#mov	$0xDF, %al	# A20 on
	#out	%al, $0x60
	#call	empty_8042
	inb     $0x92, %al	# open A20 line(Fast Gate A20).
  ac:	e4 92                	in     $0x92,%al
	orb     $0b00000010, %al
  ae:	0c 02                	or     $0x2,%al
	outb    %al, $0x92
  b0:	e6 92                	out    %al,$0x92
# messed this up with the original PC, and they haven't been able to
# rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
# which is used for the internal hardware interrupts as well. We just
# have to reprogram the 8259's, and it isn't fun.

	mov	$0x11, %al		# initialization sequence(ICW1)
  b2:	b0 11                	mov    $0x11,%al
					# ICW4 needed(1),CASCADE mode,Level-triggered
	out	%al, $0x20		# send it to 8259A-1
  b4:	e6 20                	out    %al,$0x20
  b6:	eb 00                	jmp    b8 <end_move+0x1b>
  b8:	eb 00                	jmp    ba <end_move+0x1d>
	.word	0x00eb,0x00eb		# jmp $+2, jmp $+2
	out	%al, $0xA0		# and to 8259A-2
  ba:	e6 a0                	out    %al,$0xa0
  bc:	eb 00                	jmp    be <end_move+0x21>
  be:	eb 00                	jmp    c0 <end_move+0x23>
	.word	0x00eb,0x00eb
	mov	$0x20, %al		# start of hardware int's (0x20)(ICW2)
  c0:	b0 20                	mov    $0x20,%al
	out	%al, $0x21		# from 0x20-0x27
  c2:	e6 21                	out    %al,$0x21
  c4:	eb 00                	jmp    c6 <end_move+0x29>
  c6:	eb 00                	jmp    c8 <end_move+0x2b>
	.word	0x00eb,0x00eb
	mov	$0x28, %al		# start of hardware int's 2 (0x28)
  c8:	b0 28                	mov    $0x28,%al
	out	%al, $0xA1		# from 0x28-0x2F
  ca:	e6 a1                	out    %al,$0xa1
  cc:	eb 00                	jmp    ce <end_move+0x31>
  ce:	eb 00                	jmp    d0 <end_move+0x33>
	.word	0x00eb,0x00eb		#               IR 7654 3210
	mov	$0x04, %al		# 8259-1 is master(0000 0100) --\
  d0:	b0 04                	mov    $0x4,%al
	out	%al, $0x21		#				|
  d2:	e6 21                	out    %al,$0x21
  d4:	eb 00                	jmp    d6 <end_move+0x39>
  d6:	eb 00                	jmp    d8 <end_move+0x3b>
	.word	0x00eb,0x00eb		#			 INT	/
	mov	$0x02, %al		# 8259-2 is slave(       010 --> 2)
  d8:	b0 02                	mov    $0x2,%al
	out	%al, $0xA1
  da:	e6 a1                	out    %al,$0xa1
  dc:	eb 00                	jmp    de <end_move+0x41>
  de:	eb 00                	jmp    e0 <end_move+0x43>
	.word	0x00eb,0x00eb
	mov	$0x01, %al		# 8086 mode for both
  e0:	b0 01                	mov    $0x1,%al
	out	%al, $0x21
  e2:	e6 21                	out    %al,$0x21
  e4:	eb 00                	jmp    e6 <end_move+0x49>
  e6:	eb 00                	jmp    e8 <end_move+0x4b>
	.word	0x00eb,0x00eb
	out	%al, $0xA1
  e8:	e6 a1                	out    %al,$0xa1
  ea:	eb 00                	jmp    ec <end_move+0x4f>
  ec:	eb 00                	jmp    ee <end_move+0x51>
	.word	0x00eb,0x00eb
	mov	$0xFF, %al		# mask off all interrupts for now
  ee:	b0 ff                	mov    $0xff,%al
	out	%al, $0x21
  f0:	e6 21                	out    %al,$0x21
  f2:	eb 00                	jmp    f4 <end_move+0x57>
  f4:	eb 00                	jmp    f6 <end_move+0x59>
	.word	0x00eb,0x00eb
	out	%al, $0xA1
  f6:	e6 a1                	out    %al,$0xa1
# things as simple as possible, we do no register set-up or anything,
# we let the gnu-compiled 32-bit programs do that. We just jump to
# absolute address 0x00000, in 32-bit protected mode.
	#mov	$0x0001, %ax	# protected mode (PE) bit
	#lmsw	%ax		# This is it!
	mov	%cr0, %eax	# get machine status(cr0|MSW)	
  f8:	0f 20 c0             	mov    %cr0,%eax
	bts	$0, %eax	# turn on the PE-bit 
  fb:	66 0f ba e8 00       	bts    $0x0,%ax
	mov	%eax, %cr0	# protection enabled
 100:	0f 22 c0             	mov    %eax,%cr0
				
				# segment-descriptor        (INDEX:TI:RPL)
	.equ	sel_cs0, 0x0008 # select for code segment 0 (  001:0 :00) 
	ljmp	$sel_cs0, $0	# jmp offset 0 of code segment 0 in gdt
 103:	ea                   	.byte 0xea
 104:	00 00                	add    %al,(%eax)
 106:	08 00                	or     %al,(%eax)

00000108 <empty_8042>:
 108:	eb 00                	jmp    10a <empty_8042+0x2>
 10a:	eb 00                	jmp    10c <empty_8042+0x4>
# This routine checks that the keyboard command queue is empty
# No timeout is used - if this hangs there is something wrong with
# the machine, and we probably couldn't proceed anyway.
empty_8042:
	.word	0x00eb,0x00eb
	in	$0x64, %al	# 8042 status port
 10c:	e4 64                	in     $0x64,%al
	test	$2, %al		# is input buffer full?
 10e:	a8 02                	test   $0x2,%al
	jnz	empty_8042	# yes - loop
 110:	75 f6                	jne    108 <empty_8042>
	ret
 112:	c3                   	ret    

00000113 <gdt>:
	...
 11b:	ff 07                	incl   (%edi)
 11d:	00 00                	add    %al,(%eax)
 11f:	00 9a c0 00 ff 07    	add    %bl,0x7ff00c0(%edx)
 125:	00 00                	add    %al,(%eax)
 127:	00                   	.byte 0x0
 128:	92                   	xchg   %eax,%edx
 129:	c0                   	.byte 0xc0
	...

0000012b <idt_48>:
 12b:	00 00                	add    %al,(%eax)
 12d:	00 00                	add    %al,(%eax)
	...

00000131 <gdt_48>:
 131:	00 08                	add    %cl,(%eax)
 133:	13 03                	adc    (%ebx),%eax
 135:	09 00                	or     %eax,(%eax)
